<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Mermaid Diagram</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: white;
            font-family: sans-serif;
            width: 100vw;
            height: 100vh;
        }
        #container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        #container.grabbing { cursor: grabbing; }
        .mermaid {
            display: inline-block;
            transform-origin: 0 0;
        }
        #controls {
            position: fixed;
            bottom: 16px;
            right: 16px;
            display: flex;
            gap: 6px;
            z-index: 100;
        }
        #controls button {
            width: 36px; height: 36px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: rgba(255,255,255,0.85);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #controls button:hover { background: #e0e0e0; }

        @media (prefers-color-scheme: dark) {
            body { background-color: black; }
            #controls button {
                background: rgba(50,50,50,0.85);
                border-color: #555;
                color: #eee;
            }
            #controls button:hover { background: #444; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="mermaid" id="diagram">
            {{ mermaid_code }}
        </div>
    </div>

    <div id="controls">
        <button id="zoom-in" title="Zoom In">+</button>
        <button id="zoom-out" title="Zoom Out">−</button>
        <button id="zoom-fit" title="Fit to Screen">⊞</button>
    </div>

    <script>
        /* ── Mermaid init ── */
        const theme = (window.matchMedia?.('(prefers-color-scheme: dark)').matches) ? 'dark' : 'default';
        mermaid.initialize({ startOnLoad: true, theme, themeVariables: { fontFamily: 'sans-serif' } });

        /* ── Pan & Zoom state ── */
        const container = document.getElementById('container');
        const diagram   = document.getElementById('diagram');

        let scale = 1, panX = 0, panY = 0;
        const SCALE_MIN  = 0.01;   // can zoom out to 1% — effectively no limit
        const ZOOM_SPEED = 0.001;
        const FIT_PADDING = 40;

        function applyTransform() {
            diagram.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        }

        /* ──────────────────────────────────────────────
         *  Core idea: rescale the SVG's viewBox so that
         *  its width/height attributes match the viewport.
         *  This makes the "native" SVG size = fitted size.
         *  Then scale=1 ≡ fit-to-screen, and there is
         *  NO upper zoom limit (SVG is vector, always crisp).
         * ────────────────────────────────────────────── */
        function rescaleSvgToFit() {
            const svg = diagram.querySelector('svg');
            if (!svg) return;

            // 1. Read the original viewBox (or create one from width/height)
            let vb = svg.getAttribute('viewBox');
            if (!vb) {
                const w = parseFloat(svg.getAttribute('width'))  || svg.getBoundingClientRect().width;
                const h = parseFloat(svg.getAttribute('height')) || svg.getBoundingClientRect().height;
                svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
            }

            // Remove Mermaid's inline max-width / max-height / width / height
            svg.style.maxWidth  = 'none';
            svg.style.maxHeight = 'none';
            svg.removeAttribute('width');
            svg.removeAttribute('height');

            // 2. Parse viewBox to get natural aspect ratio
            vb = svg.getAttribute('viewBox').split(/[\s,]+/).map(Number);
            const vbW = vb[2], vbH = vb[3];
            const aspect = vbW / vbH;

            // 3. Compute fitted dimensions inside the viewport (with padding)
            const vpW = container.clientWidth  - FIT_PADDING * 2;
            const vpH = container.clientHeight - FIT_PADDING * 2;

            let svgW, svgH;
            if (vpW / vpH > aspect) {
                // viewport is wider → height-constrained
                svgH = vpH;
                svgW = vpH * aspect;
            } else {
                // viewport is taller → width-constrained
                svgW = vpW;
                svgH = vpW / aspect;
            }

            // 4. Set SVG element size to the fitted size
            svg.setAttribute('width',  svgW);
            svg.setAttribute('height', svgH);

            // 5. Reset transform: scale=1, centered
            scale = 1;
            panX = (container.clientWidth  - svgW) / 2;
            panY = (container.clientHeight - svgH) / 2;
            applyTransform();
        }

        // Watch for Mermaid to inject the <svg>, then rescale
        const observer = new MutationObserver(() => {
            if (diagram.querySelector('svg')) {
                observer.disconnect();
                requestAnimationFrame(() => requestAnimationFrame(rescaleSvgToFit));
            }
        });
        observer.observe(diagram, { childList: true, subtree: true });

        window.addEventListener('resize', rescaleSvgToFit);

        /* ── Mouse wheel → zoom (NO upper limit) ── */
        container.addEventListener('wheel', e => {
            e.preventDefault();
            const oldScale = scale;
            const delta    = -e.deltaY * ZOOM_SPEED;
            scale = Math.max(SCALE_MIN, scale * (1 + delta));  // only lower bound

            const rect = container.getBoundingClientRect();
            const cx   = e.clientX - rect.left;
            const cy   = e.clientY - rect.top;
            panX = cx - (cx - panX) * (scale / oldScale);
            panY = cy - (cy - panY) * (scale / oldScale);
            applyTransform();
        }, { passive: false });

        /* ── Mouse drag → pan ── */
        let isDragging = false, startX, startY;

        container.addEventListener('pointerdown', e => {
            isDragging = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;
            container.classList.add('grabbing');
            container.setPointerCapture(e.pointerId);
        });
        container.addEventListener('pointermove', e => {
            if (!isDragging) return;
            panX = e.clientX - startX;
            panY = e.clientY - startY;
            applyTransform();
        });
        container.addEventListener('pointerup', () => {
            isDragging = false;
            container.classList.remove('grabbing');
        });

        /* ── Touch pinch → zoom (NO upper limit) ── */
        let lastPinchDist = null;
        function pinchDist(t) {
            return Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
        }

        container.addEventListener('touchstart', e => {
            if (e.touches.length === 2) lastPinchDist = pinchDist(e.touches);
        }, { passive: true });
        container.addEventListener('touchmove', e => {
            if (e.touches.length !== 2 || !lastPinchDist) return;
            e.preventDefault();
            const newDist  = pinchDist(e.touches);
            const oldScale = scale;
            scale = Math.max(SCALE_MIN, scale * (newDist / lastPinchDist));  // no upper bound
            const rect = container.getBoundingClientRect();
            const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
            const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
            panX = cx - (cx - panX) * (scale / oldScale);
            panY = cy - (cy - panY) * (scale / oldScale);
            lastPinchDist = newDist;
            applyTransform();
        }, { passive: false });
        container.addEventListener('touchend', () => { lastPinchDist = null; });

        /* ── Button controls ── */
        function zoomAtCenter(factor) {
            const oldScale = scale;
            scale = Math.max(SCALE_MIN, scale * factor);  // no upper bound
            const cx = container.clientWidth  / 2;
            const cy = container.clientHeight / 2;
            panX = cx - (cx - panX) * (scale / oldScale);
            panY = cy - (cy - panY) * (scale / oldScale);
            applyTransform();
        }

        document.getElementById('zoom-in').addEventListener('click',  () => zoomAtCenter(1.25));
        document.getElementById('zoom-out').addEventListener('click', () => zoomAtCenter(0.8));
        document.getElementById('zoom-fit').addEventListener('click', rescaleSvgToFit);
    </script>
</body>
</html>
